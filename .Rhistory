#' @importFrom stat density
#' @importFrom grDevices hcl
#' @export
plot.gpc = function(x, f = FALSE, ...){
theta_var = paste0("theta[",1:x$p,"]")
f_var = paste0("f[", 1:x$n, "]")
chain_var = paste0("chain",1:x$nchains)
nsteps = nrow(x$chain1)
par(mfrow=c(min(x$p, 4), 2))
chain_col_f <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
chain_cols = chain_col_f(x$nchains)
if(f){
all_f = x[[chain_var[1]]]
if(object$nchains > 1){
for(i in 2:x$nchains) all_f = rbind(all_f, x[[chain_var[i]]][,f_var])
}
if(x$n > 4) par(ask=TRUE)
for(t in 1:x$n){
yup = max(all_f)
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,f_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = f_var[t], main = paste(f_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,f_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,f_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,f_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = f_var[t], main = paste(f_var[t], "density"))
}
if(x$n > 4) par(ask=FALSE)
} else {
if(x$p > 4) par(ask=TRUE)
for(t in 1:x$p){
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,theta_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = theta_var[t], main = paste(theta_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,theta_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,theta_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,theta_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = theta_var[t], main = paste(theta_var[t], "density"))
}
if(x$p > 4) par(ask=FALSE)
}
par(mfrow=c(1,1))
}
debug(plot.gpc)
plot(fit, f=TRUE)
plot(fit, f=TRUE)
#' @param x object of type '\code{gpc}', output from \code{\link{gpc}}
#' @param ... further arguments to be passed to plot
#'
#' @return
#' trace and density plot of the model fit
#'
#' @importFrom graphics par plot lines
#' @importFrom stat density
#' @importFrom grDevices hcl
#' @export
plot.gpc = function(x, f = FALSE, ...){
theta_var = paste0("theta[",1:x$p,"]")
f_var = paste0("f[", 1:x$n, "]")
chain_var = paste0("chain",1:x$nchains)
nsteps = nrow(x$chain1)
par(mfrow=c(min(x$p, 4), 2))
chain_col_f <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
chain_cols = chain_col_f(x$nchains)
if(f){
all_f = x[[chain_var[1]]]
if(x$nchains > 1){
for(i in 2:x$nchains) all_f = rbind(all_f, x[[chain_var[i]]][,f_var])
}
if(x$n > 4) par(ask=TRUE)
for(t in 1:x$n){
yup = max(all_f)
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,f_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = f_var[t], main = paste(f_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,f_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,f_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,f_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = f_var[t], main = paste(f_var[t], "density"))
}
if(x$n > 4) par(ask=FALSE)
} else {
if(x$p > 4) par(ask=TRUE)
for(t in 1:x$p){
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,theta_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = theta_var[t], main = paste(theta_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,theta_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,theta_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,theta_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = theta_var[t], main = paste(theta_var[t], "density"))
}
if(x$p > 4) par(ask=FALSE)
}
par(mfrow=c(1,1))
}
debug(plot.gpc)
plot(fit, f=TRUE)
plot(fit, f=TRUE)
#' @param x object of type '\code{gpc}', output from \code{\link{gpc}}
#' @param ... further arguments to be passed to plot
#'
#' @return
#' trace and density plot of the model fit
#'
#' @importFrom graphics par plot lines
#' @importFrom stat density
#' @importFrom grDevices hcl
#' @export
plot.gpc = function(x, f = FALSE, ...){
theta_var = paste0("theta[",1:x$p,"]")
f_var = paste0("f[", 1:x$n, "]")
chain_var = paste0("chain",1:x$nchains)
nsteps = nrow(x$chain1)
par(mfrow=c(min(x$p, 4), 2))
chain_col_f <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
chain_cols = chain_col_f(x$nchains)
if(f){
all_f = x[[chain_var[1]]][,f_var]
if(x$nchains > 1){
for(i in 2:x$nchains) all_f = rbind(all_f, x[[chain_var[i]]][,f_var])
}
if(x$n > 4) par(ask=TRUE)
for(t in 1:x$n){
yup = max(all_f)
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,f_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = f_var[t], main = paste(f_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,f_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,f_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,f_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = f_var[t], main = paste(f_var[t], "density"))
}
if(x$n > 4) par(ask=FALSE)
} else {
if(x$p > 4) par(ask=TRUE)
for(t in 1:x$p){
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,theta_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = theta_var[t], main = paste(theta_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,theta_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,theta_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,theta_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = theta_var[t], main = paste(theta_var[t], "density"))
}
if(x$p > 4) par(ask=FALSE)
}
par(mfrow=c(1,1))
}
debug(plot.gpc)
plot(fit, f=TRUE)
all_f
yup
#' @param x object of type '\code{gpc}', output from \code{\link{gpc}}
#' @param ... further arguments to be passed to plot
#'
#' @return
#' trace and density plot of the model fit
#'
#' @importFrom graphics par plot lines
#' @importFrom stat density
#' @importFrom grDevices hcl
#' @export
plot.gpc = function(x, f = FALSE, ...){
theta_var = paste0("theta[",1:x$p,"]")
f_var = paste0("f[", 1:x$n, "]")
chain_var = paste0("chain",1:x$nchains)
nsteps = nrow(x$chain1)
par(mfrow=c(min(x$p, 4), 2))
chain_col_f <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
chain_cols = chain_col_f(x$nchains)
if(f){
all_f = x[[chain_var[1]]][,f_var]
if(x$nchains > 1){
for(i in 2:x$nchains) all_f = rbind(all_f, x[[chain_var[i]]][,f_var])
}
if(x$n > 4) par(ask=TRUE)
for(t in 1:x$n){
yr = range(all_f[,t])
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,f_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = f_var[t], main = paste(f_var[t], "trace"),
ylim = yr)
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,f_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,f_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,f_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = f_var[t], main = paste(f_var[t], "density"))
}
if(x$n > 4) par(ask=FALSE)
} else {
all_theta = x[[chain_var[1]]][,theta_var]
if(x$nchains > 1){
for(i in 2:x$nchains) all_theta = rbind(all_theta, x[[chain_var[i]]][,theta_var])
}
if(x$p > 4) par(ask=TRUE)
for(t in 1:x$p){
yr = range(all_theta[,t])
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,theta_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = theta_var[t], main = paste(theta_var[t], "trace"))
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,theta_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,theta_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,theta_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = theta_var[t], main = paste(theta_var[t], "density"))
}
if(x$p > 4) par(ask=FALSE)
}
par(mfrow=c(1,1))
}
plot(fit, f=TRUE)
plot(fit)
plot(fit)
#' @param x object of type '\code{gpc}', output from \code{\link{gpc}}
#' @param ... further arguments to be passed to plot
#'
#' @return
#' trace and density plot of the model fit
#'
#' @importFrom graphics par plot lines
#' @importFrom stat density
#' @importFrom grDevices hcl
#' @export
plot.gpc = function(x, f = FALSE, ...){
theta_var = paste0("theta[",1:x$p,"]")
f_var = paste0("f[", 1:x$n, "]")
chain_var = paste0("chain",1:x$nchains)
nsteps = nrow(x$chain1)
par(mfrow=c(min(x$p, 4), 2))
chain_col_f <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
chain_cols = chain_col_f(x$nchains)
if(f){
all_f = x[[chain_var[1]]][,f_var]
if(x$nchains > 1){
for(i in 2:x$nchains) all_f = rbind(all_f, x[[chain_var[i]]][,f_var])
}
if(x$n > 4) par(ask=TRUE)
for(t in 1:x$n){
yr = range(all_f[,t])
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,f_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = f_var[t], main = paste(f_var[t], "trace"),
ylim = yr)
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,f_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,f_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,f_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = f_var[t], main = paste(f_var[t], "density"))
}
if(x$n > 4) par(ask=FALSE)
} else {
all_theta = x[[chain_var[1]]][,theta_var]
if(x$nchains > 1){
for(i in 2:x$nchains) all_theta = rbind(all_theta, x[[chain_var[i]]][,theta_var])
}
if(x$p > 4) par(ask=TRUE)
for(t in 1:x$p){
yr = range(all_theta[,t])
for(i in 1:x$nchains){
if(i==1) plot(1:nsteps, x[[chain_var[i]]][,theta_var[t]], type="l", col = chain_cols[i],
xlab = "Iterations", ylab = theta_var[t], main = paste(theta_var[t], "trace"),
ylim = yr)
if(i!=1) lines(1:nsteps, x[[chain_var[i]]][,theta_var[t]], col = chain_cols[i])
}
theta_dens = x[[chain_var[1]]][,theta_var[t]]
for(i in 2:x$nchains) theta_dens = rbind(theta_dens, x[[chain_var[i]]][,theta_var[t]])
plot(density(theta_dens), xlab = "Density",
ylab = theta_var[t], main = paste(theta_var[t], "density"))
}
if(x$p > 4) par(ask=FALSE)
}
par(mfrow=c(1,1))
}
plot(fit)
setwd("~/Documents/GroupProjectTB2/GPclassification/code/hpc")
library(gpc)
# These should already be installed on the HPC prior to running
library(Rcpp)
library(mvtnorm)
source("fit_model.R")
source("generate_gp_data.R")
# Test HPC first with simulated data
sim_data = generate_gp_data()
k <- kernel_gaussian <- function(x, y, theta){
return(theta[1] * exp(-0.5 / theta[2]^2 * sum((x - y)^2)))
}
gpc(sim_data$y, sim_data$x, 50, 5, 2, 50, init_theta = c(.5,.5), kernel="gaussian")
library(gpc)
# These should already be installed on the HPC prior to running
library(Rcpp)
library(mvtnorm)
source("generate_gp_data.R")
# Test HPC first with simulated data
sim_data = generate_gp_data()
k <- kernel_gaussian <- function(x, y, theta){
return(theta[1] * exp(-0.5 / theta[2]^2 * sum((x - y)^2)))
}
gpc(sim_data$y, sim_data$x, 50, 5, 2, 50, init_theta = c(.5,.5), kernel="gaussian")
gpc(sim_data$y, sim_data$x, 50, 5, 2, 50, init_theta = c(.5,.5), kernel="gaussian")
library(gpc)
gpc(sim_data$y, sim_data$x, 50, 5, 2, 50, init_theta = c(.5,.5), kernel="gaussian")
# These should already be installed on the HPC prior to running
library(Rcpp)
library(mvtnorm)
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
source("fit_model.R")
source("generate_gp_data.R")
# These should already be installed on the HPC prior to running
library(Rcpp)
library(mvtnorm)
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
source("fit_model.R")
source("generate_gp_data.R")
# These should already be installed on the HPC prior to running
library(Rcpp)
library(mvtnorm)
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
source("fit_model.R")
source("generate_gp_data.R")
# These should already be installed on the HPC prior to running
library(Rcpp)
library(mvtnorm)
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
source("fit_model.R")
source("generate_gp_data.R")
a
# Test HPC first with simulated data
sim_data = generate_gp_data()
k <- kernel_gaussian <- function(x, y, theta){
return(theta[1] * exp(-0.5 / theta[2]^2 * sum((x - y)^2)))
}
gpc(sim_data$y, sim_data$x, 50, 5, 1, 50, init_theta = c(.5,.5), kernel=k)
source("generate_gp_data.R")
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
# Test HPC first with simulated data
sim_data = generate_gp_data()
k <- kernel_gaussian <- function(x, y, theta){
return(theta[1] * exp(-0.5 / theta[2]^2 * sum((x - y)^2)))
}
# fit
system.time(
gpc(sim_data$y, sim_data$x, 50, 5, 1, 50, init_theta = c(.5,.5), kernel=k)
)    # 46 seconds elapsed
# Source components of gpc package separately
sourceCpp("gp_C_hpc.cpp")
# fit
system.time(
gpc(sim_data$y, sim_data$x, 50, 5, 1, 50, init_theta = c(.5,.5), kernel=k)
)    # 46 seconds elapsed
system.time(
gpc(sim_data$y, sim_data$x, 50, 5, 1, 50, init_theta = c(.5,.5), kernel="gaussian")
)   #
roxygen2::roxygenize(roclets="rd")  # this updates the documentation based on roxygen comments
setwd("~/Documents/GroupProjectTB2/GPclassification/code/package/gpc")
roxygen2::roxygenize(roclets="rd")  # this updates the documentation based on roxygen comments
library(gpc)
roxygen2::roxygenize(roclets="rd")  # this updates the documentation based on roxygen comments
library(Rcpp)
library(gpc)
# read spam data
data <- read.csv("./spambase_csv.csv")
setwd("~/Documents/GroupProjectTB2/GPclassification/code")
# read spam data
data <- read.csv("./spambase_csv.csv")
colnames(data)
response <- 58
n <- nrow(data)
scaled_data <- scale(data)
data[,58]
scaled_data[,58]
data <- cbind(scaled_data[,-58], data[,58])
tdata <- data[sample(1:n, 500),]
X <- tdata[,-response]; y <- tdata[,response]
y[y == 0] <- -1
y
X
gaussian_kernel = function(x, y, theta) theta[1] * exp(-0.5 / theta[2]^2 * sum((x - y)^2))
subset = ivm_subset_selection(X, gaussian_kernel, c(1,1), 250)
subset
nrow(data)
gpc::build_K(X, X, gaussian_kernel, c(1,1))
K = gpc::build_K(X, X, gaussian_kernel, c(1,1))
nimp_seq = seq(10, 400, by=50)
N = 4
pseudo = matrix(NA, length(nimp_seq), N)
for(i in 1:length(nimp_seq)){
for(j in 1:N){
set.seed(j)
pseudo[i, j] = get_approx_marginal(y = dat$y, K = dat$K, nimp = nimp_seq[i],
theta = c(1,1), laplace_approx = la)
cat("\r", j, "/", N); flush.console()
}; cat("\n")
cat(i, "/", length(nimp_seq), "\n", sep="")
}
pseudo = matrix(NA, length(nimp_seq), N)
for(i in 1:length(nimp_seq)){
for(j in 1:N){
set.seed(j)
pseudo[i, j] = get_approx_marginal(y = y, K = K, nimp = nimp_seq[i],
theta = c(1,1), laplace_approx = la)
cat("\r", j, "/", N); flush.console()
}; cat("\n")
cat(i, "/", length(nimp_seq), "\n", sep="")
}
la = laplace_approx(y, K)
nimp_seq = seq(10, 400, by=50)
N = 4
pseudo = matrix(NA, length(nimp_seq), N)
for(i in 1:length(nimp_seq)){
for(j in 1:N){
set.seed(j)
pseudo[i, j] = get_approx_marginal(y = y, K = K, nimp = nimp_seq[i],
theta = c(1,1), laplace_approx = la)
cat("\r", j, "/", N); flush.console()
}; cat("\n")
cat(i, "/", length(nimp_seq), "\n", sep="")
}
library(ggplot2)
library(latex2exp)
pd = data.frame(x=nimp_seq, y = rowMeans(pseudo),
up = apply(pseudo, 1, quantile, probs=0.025),
lo = apply(pseudo, 1, quantile, probs=0.975))
ggplot(pd) + geom_line(aes(x, y, colour = "Mean"), size=1.15) +
geom_point(aes(x, y, colour = "Mean"), size=3) +
geom_ribbon(aes(ymin = lo, ymax = up, x=x, fill="95% Interval"), alpha=0.25) +
xlab(TeX("$N_{imp}$")) + ylab("Approx. Pseudo Marginal")
nimp_seq = seq(10, 500, by=25)
N = 32
pseudo = matrix(NA, length(nimp_seq), N)
for(i in 1:length(nimp_seq)){
for(j in 1:N){
set.seed(j)
pseudo[i, j] = get_approx_marginal_par(y = y, K = K, nimp = nimp_seq[i],
theta = c(1,1), laplace_approx = la)
cat("\r", j, "/", N); flush.console()
}; cat("\n")
cat(i, "/", length(nimp_seq), "\n", sep="")
}
library(ggplot2)
library(latex2exp)
pd = data.frame(x=nimp_seq, y = rowMeans(pseudo),
up = apply(pseudo, 1, quantile, probs=0.025),
lo = apply(pseudo, 1, quantile, probs=0.975))
ggplot(pd) + geom_line(aes(x, y, colour = "Mean"), size=1.15) +
geom_point(aes(x, y, colour = "Mean"), size=3) +
geom_ribbon(aes(ymin = lo, ymax = up, x=x, fill="95% Interval"), alpha=0.25) +
xlab(TeX("$N_{imp}$")) + ylab("Approx. Pseudo Marginal")
pseudo[i, j] = gpc::get_approx_marginal_par(y = y, K = K, nimp = nimp_seq[i],
theta = c(1,1), laplace_approx = la)
nimp_seq = seq(10, 500, by=25)
N = 32
pseudo = matrix(NA, length(nimp_seq), N)
for(i in 1:length(nimp_seq)){
for(j in 1:N){
set.seed(j)
pseudo[i, j] = gpc::get_approx_marginal_par(y = y, K = K, nimp = nimp_seq[i],
theta = c(1,1), laplace_approx = la)
cat("\r", j, "/", N); flush.console()
}; cat("\n")
cat(i, "/", length(nimp_seq), "\n", sep="")
}
library(ggplot2)
library(latex2exp)
pd = data.frame(x=nimp_seq, y = rowMeans(pseudo),
up = apply(pseudo, 1, quantile, probs=0.025),
lo = apply(pseudo, 1, quantile, probs=0.975))
ggplot(pd) + geom_line(aes(x, y, colour = "Mean"), size=1.15) +
geom_point(aes(x, y, colour = "Mean"), size=3) +
geom_ribbon(aes(ymin = lo, ymax = up, x=x, fill="95% Interval"), alpha=0.25) +
xlab(TeX("$N_{imp}$")) + ylab("Approx. Pseudo Marginal")
